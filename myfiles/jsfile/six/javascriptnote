对任意单位做加减
   1.获得单位当前值
   2.计算
   3.set回去
简写:  date.setxxx(date.getxxx()+n)
强调:setxx()直接修改前后两个日期对象,应该在

前复制原日期对象的副本,再用副本计算新日期

格式化: 
   .toString();转为当地时间的完整格式
   .toLocaleString();  转为当地时间的简化格式
   .toLocaleDateString();   当地时间的简化格式,仅保留日期部分简化格式
   .toLocaleTimeString();     仅保留时分秒部分
   .toGMTString();   转为国际标准时间(0时区)

Error   
什么是Error: 程序 执行过程中遇到无法执行的异常情况
程序出错都会强行中断退出
错误处理: 即使发生错误,也保证程序不中断退出的一种机制
什么时候:  几乎所有程序只要可能发生错误,都要提前进行错误处理,

语法:  
   try{
      可能发生错误的正确代码
   }catch(err){
      //err:   错误对象,自动保存错误信息
      只有发生错误时才执行的的错误代码
      包括: 提示用户,记录日志
   }

问题: 1.try  catch 比正常程序执行的效率低,
      2.被动的接收错误,无法精确提示用户
解决: 尽量提前预知错误原因,用if else代替try catch
抛出自定义错误:   
   throw new Error("自定义错误信息")
什么时候抛出错误信息: 在协作开发中,只要函数的作者向函数的调用者抛出错误说明错误的使用了函数

Js中的错误类型:   
   六种:   SyntaxError  :  语法错误
           ReferenceError:   引用错误   要用的 变量没找到
           TypeError  :    类型错误  错误的使用了类型
           RangeError  :  范围错误,参数超范围  
           URLError  :  
           EvalError  :
Js创始人:   布兰登·艾奇

Function :  
   什么是Function:  内存中保存一段代码的对象
   什么时候使用 : 当程序中,有一项任务可能被反复执行时,都要将任务的代码段,先保存在函数对象中,再反复调用函数执行
   声明:
   function 函数名(){

      return 返回值
   }

   参数: 调用函数时,接收传入函数的数量的变量
   何时使用:如果函数自身必须某些参数才能正常执行,就必须定义参数
   返回值:  函数的执行结果,返回值并不是必须的,
   何时需要返回值:  如果调用者需要获得函数的执行结果时,那么就需要返回值了
声明提前(hoist): 在程序开始执行前先将var声明的变量和function声明的函数提前到当前作用域的顶部集中创建
解决:  用赋值方式创建函数对象
  var 函数名 = function(参数列表){
     代码片段
     return 返回值;
  }
优点: 不会被声明提前

揭示了: 函数名其实就是一个普通的变量名
      函数其实就是一个对象
      函数名通过 地址 引用函数对象的
var fun = new Function("a","b","函数体");
 笔试题:   以下创建函数不正确的是:   
   function fun (a,b){return}
   var fun = function(a,b){return}
   var fun = new Function(a,b,"retutn a-b")   //错
   var fun = new Function("a","b","retutn a-b")
函数的重载    
   相同函数名,不同参数列表的多个函数,在调用时可以跟据传入的数据不同,自动
   为什么:  减少API的数量,减轻调用者的负担
   什么时候使用: 如果一件事根据传入的参数不同执行不同的操作

问题js默认不支持函数重载
   解决: arguments对象,变通实现
   arguments   每个函数内自动创建的的接收接收所有传入参数值的类数组对象

VS 数组 :  相同:   1.length   2.下标  3.遍历
            不同:   API不同
匿名函数  
   什么是匿名函数:  定义时未指定名称的函数
   为什么: 节约内存,划分临时作用域
   何时:  只要一个函数只使用一次,不会重复使用时
   任何使用:  
         arr.sort(function(a,b){return a-b;})
         str.replace(reg,function(kw){return 值})
      匿名函数自调:  
        什么是; 临时创建一个匿名函数后,立即调用自己
        为什么;   避免使用全局变量,造成全局污染
      何时: 所有功能代码都要放在 匿名函数自调内

      如何; 
      (function(参数 列表){
         函数体;
         返回值
      })  (参数列表);

eg:    (0=>{
         轮播
      }) ();
      (0=>{
         登入
      }) ();

垃圾回收   
    什么是垃圾:   一个不再被任何变量使用的对象
    什么是垃圾回收:   引擎会自动检测不再使用的对象,并自动释放其内容空间
    为什么: 内存容量是极其有限的
    垃圾回收器:  专门检测并回收垃圾对象的的小程序js引擎自带
      何时:  只要引擎检测到不再使用的对象,就会自动释放该对象的内容空间
   如何:  1.垃圾回收器伴随主程序执行而并行执行
          2.垃圾回收器会记录每个对象被几个变量引用着
          3.只要垃圾回收器发现一个对象不再被任何变量引用着,就自动释放该对象
****     Lorem   按回车会出现很多字母
函数调用后所有局部变量都会释放,不能被重用


作用域和作用域链
  作用域(scope):
  什么是作用域:   一个变量的使用范围
  本质: 是一个存储变量的对象
   为什么:   为了避免函数内外的变量互相干扰
   1.全局作用域:   保存着所有的变量/函数随处可以使用的,可以反复使用
   2.函数作用域:   保存着函数内的局部变量,仅仅在函数内部使用,且不可以重用
函数其实是有生命周期的
   函数执行前,   
   创建一个数组 (执行环境栈 ECS):用于记录正在执行的函数,
   浏览器本身也是一个程序,执行环境栈中默认首先记录的是
   Main()函数执行的时候会创建全局作用域对象window
   1.保存浏览器自己需要的数据和对象
   2.作为程序的全局作用域对象,保存全局变量
   函数定义时,
      在全局创建函数名变量
      在window之外创建函数对象保存函数定义
      函数名变量通过地址引用函数对象,
      函数对象使用scope属性指回自己来时的作用域
   函数调用时,
      先在ECS中添加本次函数调用的记录
      调用的时候会创建一个AO函数作用域对象
      在函数作用域对象中保存本次函数调用所需的所有局部变量
      函数作用域对象的parent属性指向函数来自父级作用域对象
      所以变量的使用顺序是: (就近)先用局部的变量,如果局部没有就在上一级找

   函数调用后,
   将本次函数调用的记录从ECS中出栈
   导致函数作用域对象释放,
   导致局部变量一同释放
   所以局部变量不可以重用

作用域链 :   是由多级作用域逐级引用形成链式结构
保存了: 所有的变量
控制了: 变量的使用顺序































